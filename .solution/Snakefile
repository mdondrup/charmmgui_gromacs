# Snakefile for running the Gromacs MD simulation package

# Define the input files and parameters
init = "step3_input"  # Initial structure file prefix

# Define the prefixes for each step
mini_prefix = "step4.0_minimization"

equi_prefix = "step4.1_equilibration"

prod_prefix = "step5_production"

prod_step = "step5"

onsuccess:
    print("GROMACS Workflow finished successfully")

onerror:
    print("An error occurred, see the log files for details {log}")


# Define local rules, i.e., rules that will always be executed 
# locally
localrules:
    all,
    clean,


rule all:
    input:
        f"{prod_step}_10.gro",
    message:
        "All steps completed successfully"


# Rule to perform energy minimization


rule minimize:
    input:
        top="topol.top",
        mdp=f"{mini_prefix}.mdp",
        init=f"{init}.gro",
        index="index.ndx",
    output:
        em=f"{mini_prefix}.tpr",
        edr=f"{mini_prefix}.edr",
        out=f"{mini_prefix}.gro",
    log:
        f"logs/{mini_prefix}.log",
    message:
        "Running energy minimization"
    shell:
        """
        gmx grompp -f {input.mdp} -o {output.em}\
            -c {input.init}\
            -r {input.init}\
            -p {input.top}\
            -n {input.index}\
            -maxwarn 1   > {log} 2>&1
        gmx mdrun -v -deffnm {mini_prefix}   >> {log} 2>&1
        """


# Rule to perform equilibration
rule equilibrate:
    input:
        top="topol.top",
        mdp=f"{equi_prefix}.mdp",
        init=f"{init}.gro",
        index="index.ndx",
        in_gro=f"{mini_prefix}.gro",
    output:
        em=f"{equi_prefix}.tpr",
        out=f"{equi_prefix}.gro",
        edr=f"{equi_prefix}.edr",
    log:
        f"logs/{equi_prefix}.log",
    message:
        "Running equilibration"
    shell:
        """
        gmx grompp -f {input.mdp} -o {output.em}\
            -c {input.in_gro}\
            -r {input.init}\
            -p {input.top}\
            -n {input.index}\
            -maxwarn 1 > {log} 2>&1 
        gmx mdrun -v -deffnm {equi_prefix} >> {log} 2>&1
        """


# Create 10 production run rules using a for loop
for cnt in range(1, 11):
    ##############################################################################
    # Rule to perform production runs
    ##############################################################################

    rule:
        name:
            f"production_{cnt}"
        input:
            top="topol.top",
            mdp=f"{prod_prefix}.mdp",
            init=f"{equi_prefix}.gro" if cnt == 1 else f"{prod_step}_{cnt-1}.gro",
            index="index.ndx",
            previous_cpt=f"{prod_step}_{cnt-1}.cpt" if cnt > 1 else [],
        output:
            tpr=f"{prod_step}_{cnt}.tpr",
            gro=f"{prod_step}_{cnt}.gro",
            edr=f"{prod_step}_{cnt}.edr",
            cpt=f"{prod_step}_{cnt}.cpt",
        params:
            cnt=cnt,
        log:
            f"logs/{prod_step}_{cnt}.log",
        message:
            f"Running production step {cnt}"
        shell:
            """
            echo "Starting production step {params.cnt}"
            if [ "{input.previous_cpt}xxx" == "xxx" ]; then
                CONT_FLAG=""
            else
                CONT_FLAG="-t {input.previous_cpt}"
            fi
            gmx grompp -f {input.mdp} -o {output.tpr}\
                -c {input.init}\
                -p {input.top}\
                -n {input.index} ${{CONT_FLAG}}\
                -maxwarn 1 > {log} 2>&1
            gmx mdrun -v -deffnm {prod_step}_{params.cnt} >> {log} 2>&1
            """


# Rule to clean up intermediate files
rule clean:
    shell:
        """
        rm -f step4*.gro step5*.gro *.cpt *.log *.trr *.edr *.tpr *.xtc \\#*#
        """
